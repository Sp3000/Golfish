         NOP
!        Trampoline: add 1 to skip count
"        String parsing - push chars until closing ", backtick escapes "`nr
#        4-way mirror
$        Swap two
%        Modulo (always nonnegative)
S%       GCD
&        Save to register/push from register
'        String parsing - push chars until closing ', backtick escapes '`nr
(        Less than
S(       Floor
)        Greater than
S)       Ceil
*        Multiply
+        Add
,        Floating point division
S,       Integer division
-        Subtract
.        Pop y, x and jump to (x, y)
/        Mirror
0        Push 0
1        Push 1
2        Push 2
S2       Push e
3        Push 3
S3       Push pi
4        Push 4
5        Push 5
6        Push 6
7        Push 7
8        Push 8
9        Push 9
:        Duplicate
;        Halt with no output
<        Move left
=        Equals
S=       Round
>        Move right
?        Conditional: pop and execute next if truthy, else skip 1
@        Rotate 3, moving 3rd down to top
A        
B        
C        <unimplemented: for loop counter>
SC       Cosine
D        Debug, outputting stack. Does not count as an instruction for conditionals/trampolines.
E        Conditional: Pop and execute next if EOF (-1), else skip 1 and re-push. Essentially :m=? except it gets rid of the -1 as well.
F        <unimplemented: for loop>
G        
H        Output stack as char until empty then halt
I        Numeric input: Read next non-negative int/float. Push -1 on EOF.
SI       Numeric input: Read next int/float (possible negative). Change direction to down on EOF.
J        Conditional jump: pop cond, y, x and jump to (x, y) if cond
K        Multiple copy: Pop n and copy the top n elements
L        <unimplemented: resume loop>
SL       Pop b,a and push log(a,b)
M        Minus 1
N        Output as num + trailing newline
O        
P        Plus 1
SP       Primality test
Q        Conditional: Pop n, then pop and execute next if truthy, else skip n
R        Pop n, repeat next instruction n times (experimental)
S        Switch: Toggle next instruction
SS       Sine
T        Set teleport pad
ST       Tangent
U        
V        Pops element and saves to variable determined by next char
W        <unimplemented: while loop>
X        Exponentiation
SX       Push random float in [0, 1)
Y        
Z        Conditional: Pop and execute next if zero/falsy, else skip 1
[        Pop n. Move one stack left, taking the top n elements with you.
\        Mirror
]        Pop n. Move one stack right, taking the top n elements with you.
^        Move up
_        Horizontal mirror
`        Escape next to char, pushing to stack
a        Push 10
b        Push 11
c        Push 12
d        Push 13
e        Push 14
f        Push 15
g        Pop y, x and push char at (x, y)
h        Halt and output top of stack as num
i        Read char
j
k        Get nth element down (top is 0)
l        Push length of stack
Sl       Lowercase
m        Push -1
n        Output as num
o        Output as char
p        Pop y, x, char and put char at (x, y)
q        Conditional: pop and execute next if truthy, else skip 2
r        Reverse stack
s        
t        Teleport to last teleport pad
u        
Su       Uppercase
v        Move down
w        
x        Random direction
Sx       
y        
z        Is zero: Push 1 if zero, else 0
{        Shift stack left
|        Mirror
}        Shift stack right
~        Pop and discard
